# Bloom Implementation Guide

This document contains the specific implementation details for Bloom, extracted from the main Florist release handler plan.

## Core Module Implementations

### Bloom.ReleaseManager

```elixir
defmodule Bloom.ReleaseManager do
  @moduledoc """
  Main interface for release operations using :release_handler
  """
  
  def install_release(version) do
    with :ok <- validate_release(version),
         {:ok, _} <- :release_handler.unpack_release(version),
         :ok <- verify_installation(version) do
      :ok
    else
      error -> {:error, error}
    end
  end
  
  def switch_release(version) do
    with :ok <- pre_switch_checks(version),
         {:ok, _} <- :release_handler.install_release(version),
         :ok <- post_switch_validation(),
         :ok <- :release_handler.make_permanent(version) do
      log_successful_switch(version)
      :ok
    else
      error -> 
        attempt_rollback()
        {:error, error}
    end
  end
  
  def list_releases do
    :release_handler.which_releases()
    |> Enum.map(&format_release_info/1)
  end
  
  def current_release do
    case :release_handler.which_releases(:current) do
      [{name, version, _libs, status}] -> 
        %{name: name, version: version, status: status}
      [] -> 
        {:error, :no_current_release}
    end
  end
  
  def rollback_release do
    with [{_name, prev_version, _libs, _status}] <- previous_release(),
         :ok <- switch_release(prev_version) do
      :ok
    else
      [] -> {:error, :no_previous_release}
      error -> error
    end
  end
end
```

### Bloom.HealthChecker

```elixir
defmodule Bloom.HealthChecker do
  @checks []
  
  def register_check(name, check_function) do
    # Allow applications to register custom health checks
  end
  
  def run_checks do
    @checks
    |> Enum.map(&run_check/1)
    |> Enum.all?(&(&1 == :ok))
  end
  
  def post_switch_validation do
    # Run critical checks after a release switch
    # - HTTP endpoints responding
    # - Database connectivity
    # - Essential GenServers running
    # - Memory/CPU within normal ranges
  end
end
```

### Bloom.RPC

```elixir
defmodule Bloom.RPC do
  @moduledoc """
  Handles remote procedure calls from Florist CLI
  """
  
  def handle_call({:install_release, version}, _from, state) do
    result = Bloom.ReleaseManager.install_release(version)
    {:reply, result, state}
  end
  
  def handle_call({:switch_release, version}, _from, state) do
    result = Bloom.ReleaseManager.switch_release(version)
    {:reply, result, state}
  end
  
  def handle_call(:list_releases, _from, state) do
    result = Bloom.ReleaseManager.list_releases()
    {:reply, result, state}
  end
  
  # Authentication and security
  defp authenticate_caller(caller_info) do
    # Verify caller is authorized Florist instance
    # Could use shared secrets, certificates, or other auth
  end
end
```

## Safety and Monitoring

### Release Validation

```elixir
defmodule Bloom.Validator do
  def validate_release(version) do
    checks = [
      &check_release_exists/1,
      &check_version_format/1,
      &check_dependencies/1,
      &check_disk_space/1
    ]
    
    run_validation_checks(version, checks)
  end
  
  def check_compatibility(from_version, to_version) do
    # Check for breaking changes, data migrations needed, etc.
    # Could read from a compatibility matrix or release notes
  end
end
```

### Safety Monitor

```elixir
defmodule Bloom.SafetyMonitor do
  use GenServer
  
  def start_monitoring_switch(from_version, to_version) do
    # Start monitoring critical metrics
    # Set timer for automatic rollback if issues detected
  end
  
  def handle_info(:check_health, state) do
    if critical_failure_detected?() do
      Logger.error("Critical failure detected, initiating automatic rollback")
      Bloom.ReleaseManager.rollback_release()
    end
    
    {:noreply, state}
  end
end
```

### Release Metadata

```elixir
defmodule Bloom.Metadata do
  @metadata_file "priv/release_metadata.json"
  
  def save_release_info(version, info) do
    # Store deployment timestamp, previous version, rollback info
  end
  
  def get_rollback_target do
    # Determine which version to rollback to
  end
end
```

## Required Release File Structure

Ensure releases have proper OTP structure:

```
/sites/prod/myapp/
├── releases/
│   ├── 1.2.3/
│   │   ├── myapp.rel      # Required by :release_handler
│   │   ├── sys.config
│   │   ├── vm.args
│   │   └── myapp.tar.gz
│   ├── 1.2.4/
│   └── RELEASES           # Generated by :release_handler
├── bin/
│   └── myapp
└── lib/
```

## Error Handling

Map `:release_handler` errors to user-friendly messages:

```elixir
defp handle_release_error({:error, {:bad_relup_file, _}}) do
  {:error, "Invalid release upgrade file - check release compatibility"}
end

defp handle_release_error({:error, :no_such_release}) do
  {:error, "Release not found - ensure release is properly installed"}
end

defp handle_release_error({:error, {:already_installed, version}}) do
  {:error, "Release #{version} is already installed"}
end
```

## Testing Strategy

1. **Unit Tests**: Mock `:release_handler` calls
2. **Integration Tests**: Use dummy releases
3. **Property-Based Tests**: Release validation logic
4. **Failure Scenarios**: Network issues, corrupted releases

## Supervision Tree

```elixir
# In target application
def start(_type, _args) do
  children = [
    # existing children...
    Bloom.ReleaseManager,
    Bloom.HealthChecker,
    Bloom.RPC
  ]
  
  opts = [strategy: :one_for_one, name: MyApp.Supervisor]
  Supervisor.start_link(children, opts)
end
```

## Configuration

Optional configuration for advanced features:

```elixir
# config.exs
config :bloom,
  health_checks: [
    database: &MyApp.DatabaseChecker.check/0,
    cache: &MyApp.CacheChecker.check/0
  ],
  rollback_timeout: 30_000,
  retention_count: 10
```

## Package Dependencies

Keep minimal for lightweight package:

```elixir
# mix.exs
defp deps do
  [
    # Core Elixir/OTP only
    # Optional: {:jason, "~> 1.0"} for metadata handling
  ]
end
```

This provides everything needed to implement the core Bloom package functionality independently of Florist.